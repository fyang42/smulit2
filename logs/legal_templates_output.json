{
    "Escrow Service": "Here's a Solidity smart contract for an Escrow Service with the requested features:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract EscrowService {\n    enum State { Created, Funded, Disputed, Released, Cancelled }\n\n    // Define roles\n    enum Role { Buyer, Seller, EscrowAgent }\n\n    // Define parties\n    address public buyer;\n    address public seller;\n    address public escrowAgent;\n\n    // Define terms\n    uint256 public amount;\n    State public state;\n\n    // Mapping to store funds\n    mapping(address => uint256) public balances;\n\n    // Event logging\n    event Deposit(address indexed buyer, uint256 amount);\n    event Release(address indexed seller, uint256 amount);\n    event Dispute(address indexed buyer, address indexed seller);\n    event Resolve(address indexed winner, uint256 amount);\n    event Cancel(address indexed buyer, uint256 amount);\n\n    // Constructor function\n    constructor(address _buyer, address _seller, address _escrowAgent, uint256 _amount) {\n        buyer = _buyer;\n        seller = _seller;\n        escrowAgent = _escrowAgent;\n        amount = _amount;\n        state = State.Created;\n    }\n\n    // Deposit funds into escrow\n    function fund() public payable {\n        require(msg.sender == buyer, \"Only the buyer can fund the escrow.\");\n        require(state == State.Created, \"The escrow is not in the created state.\");\n\n        balances[buyer] += msg.value;\n        balances[address(this)] += msg.value;\n\n        emit Deposit(buyer, msg.value);\n        state = State.Funded;\n    }\n\n    // Release funds to the seller\n    function release() public {\n        require(state == State.Funded, \"The escrow is not in the funded state.\");\n        require(msg.sender == escrowAgent, \"Only the escrow agent can release funds.\");\n\n        balances[seller] += amount;\n        balances[address(this)] -= amount;\n\n        emit Release(seller, amount);\n        state = State.Released;\n    }\n\n    // Dispute the transaction\n    function dispute() public {\n        require(state == State.Funded, \"The escrow is not in the funded state.\");\n        require(msg.sender == buyer, \"Only the buyer can dispute the transaction.\");\n\n        emit Dispute(buyer, seller);\n        state = State.Disputed;\n    }\n\n    // Resolve disputes\n    function resolve(address _winner) public {\n        require(state == State.Disputed, \"The escrow is not in the disputed state.\");\n        require(msg.sender == escrowAgent, \"Only the escrow agent can resolve disputes.\");\n\n        if (_winner == buyer) {\n            balances[buyer] += amount;\n            balances[address(this)] -= amount;\n\n            emit Resolve(buyer, amount);\n            state = State.Cancelled;\n        } else if (_winner == seller) {\n            balances[seller] += amount;\n            balances[address(this)] -= amount;\n\n            emit Resolve(seller, amount);\n            state = State.Released;\n        }\n    }\n\n    // Cancel the contract\n    function cancel() public {\n        require(state == State.Created || state == State.Disputed, \"The escrow is not in the created or disputed state.\");\n        require(msg.sender == buyer, \"Only the buyer can cancel the contract.\");\n\n        balances[buyer] += amount;\n        balances[address(this)] -= amount;\n\n        emit Cancel(buyer, amount);\n        state = State.Cancelled;\n    }\n\n    // Prevent unauthorized access or tampering\n    modifier onlyRole(Role _role) {\n        require(msg.sender == buyer || msg.sender == seller || msg.sender == escrowAgent, \"Unauthorized access.\");\n        require(_role == Role.Buyer || _role == Role.Seller || _role == Role.EscrowAgent,",
    "Employment Contract": "Here is a basic template for a Solidity smart contract for an Employment Contract. Please note that this is a simplified version and may not cover all legal aspects of an employment contract. It is recommended to consult with a legal professional before using this contract in a real-world scenario.\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract EmploymentContract {\n\n    // Define roles\n    enum Role { Employer, Employee }\n\n    // Define parties\n    Role public employer;\n    Role public employee;\n\n    // Basic terms\n    string public jobTitle;\n    string public responsibilities;\n    uint256 public salary;\n\n    // Bonus system\n    struct BonusCriterion {\n        string description;\n        uint256 target;\n        uint256 reward;\n    }\n    BonusCriterion[] public bonusCriterions;\n\n    // Payment schedule\n    uint256 public paymentInterval; // in seconds\n\n    // Termination clauses\n    enum TerminationReason { Misconduct, PoorPerformance, Redundancy, MutualAgreement }\n    mapping(TerminationReason => uint256) public terminationNoticePeriods;\n    TerminationReason public lastTerminationReason;\n    bool public isTerminated;\n\n    // Confidentiality and non-compete clauses\n    bool public confidentialityAgreement;\n    bool public nonCompeteAgreement;\n\n    // Dispute resolution\n    address public arbitrator;\n\n    // Constructor\n    constructor(\n        Role _employer,\n        Role _employee,\n        string memory _jobTitle,\n        string memory _responsibilities,\n        uint256 _salary,\n        BonusCriterion[] memory _bonusCriterions,\n        uint256 _paymentInterval,\n        TerminationReason _terminationNoticePeriods,\n        address _arbitrator\n    ) {\n        employer = _employer;\n        employee = _employee;\n        jobTitle = _jobTitle;\n        responsibilities = _responsibilities;\n        salary = _salary;\n        bonusCriterions = _bonusCriterions;\n        paymentInterval = _paymentInterval;\n        terminationNoticePeriods = _terminationNoticePeriods;\n        arbitrator = _arbitrator;\n    }\n\n    // Add bonus criterion\n    function addBonusCriterion(BonusCriterion memory _bonusCriterion) external {\n        bonusCriterions.push(_bonusCriterion);\n    }\n\n    // Terminate employment\n    function terminate(TerminationReason _terminationReason) external {\n        require(!isTerminated, \"Employment is already terminated.\");\n        lastTerminationReason = _terminationReason;\n        isTerminated = true;\n    }\n\n    // Calculate bonus\n    function calculateBonus() external view returns (uint256) {\n        uint256 totalBonus = 0;\n        for (uint256 i = 0; i < bonusCriterions.length; i++) {\n            BonusCriterion storage criterion = bonusCriterions[i];\n            // Add your bonus calculation logic here\n        }\n        return totalBonus;\n    }\n\n    // Other functions as needed\n}\n```\n\nThis contract includes the following features:\n\n1. Definitions of Employer and Employee roles.\n2. Basic terms of employment, including salary, job title, and responsibilities.\n3. Performance-based bonus system, including criteria for bonuses and calculation methods.\n4. Payment schedule (not explicitly defined, but can be implemented using a separate contract or off-chain).\n5. Termination clauses, including reasons for termination and notice periods.\n6. Confidentiality and non-compete clauses (not explicitly defined, but can be implemented using boolean flags and separate agreements).\n7. Dispute resolution mechanisms, including arbitration or mediation (arbitrator address is included, but the actual dispute resolution process is not defined).\n8. Constructor function to initialize the contract with the relevant parties and terms.\n\nPlease note that this contract is a starting point and should be customized according to your specific requirements. It is important to consult with a legal professional and a Solidity expert to ensure the contract meets your needs and complies with relevant laws and regulations.",
    "NDA Contract": "Here's a basic Solidity smart contract for a Non-Disclosure Agreement (NDA) with the requested features. Please note that this is a simplified version and should be reviewed by a legal expert and audited by a blockchain security expert before deploying it on the mainnet.\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract NDA {\n    // 1. Definitions of Confidential Information and Parties involved\n    struct Party {\n        address addr;\n        string name;\n    }\n\n    Party public discloser;\n    Party public recipient;\n\n    string public confidentialInformation;\n\n    constructor(Party memory _discloser, Party memory _recipient, string memory _info) {\n        discloser = _discloser;\n        recipient = _recipient;\n        confidentialInformation = _info;\n    }\n\n    // 2. Obligations of the Recipient to maintain confidentiality\n    modifier isDiscloser() {\n        require(msg.sender == discloser.addr, \"Only the discloser can perform this action.\");\n        _;\n    }\n\n    modifier isRecipient() {\n        require(msg.sender == recipient.addr, \"Only the recipient can perform this action.\");\n        _;\n    }\n\n    function discloseInformation(string memory _info) public isDiscloser {\n        confidentialInformation = _info;\n    }\n\n    function viewInformation() public view returns (string memory) {\n        return confidentialInformation;\n    }\n\n    // 3. Duration of the confidentiality obligation\n    uint256 public duration;\n\n    constructor(Party memory _discloser, Party memory _recipient, string memory _info, uint256 _duration) {\n        discloser = _discloser;\n        recipient = _recipient;\n        confidentialInformation = _info;\n        duration = _duration;\n    }\n\n    // 4. Permitted disclosures and exceptions\n    function permittedDisclosure(address _to, string memory _info) public isRecipient {\n        require(now < (block.timestamp + duration), \"The confidentiality period has not expired.\");\n        require(_to != address(0), \"Invalid address.\");\n\n        // Check for legal requirements or other permitted disclosures\n        // For example, if the recipient is a government agency, they might be allowed to disclose the information\n        // Add your custom logic here\n\n        // If permitted, send the information\n        (bool success, ) = _to.call(abi.encodeWithSignature(\"receiveInformation(string)\", _info));\n        require(success, \"Failed to disclose information.\");\n    }\n\n    // 5. Consequences for breach of the NDA\n    event Breach(address indexed breacher);\n\n    function reportBreach(address _breacher) public {\n        require(_breacher != msg.sender, \"You cannot report yourself.\");\n        emit Breach(_breacher);\n    }\n\n    // 6. Dispute resolution mechanisms\n    // Add your custom logic here\n\n    // 7. Constructor function to initialize the contract with the relevant parties and terms\n    // Already implemented in the constructor\n}\n```\n\nThis contract includes the following features:\n\n1. Definitions of Confidential Information and Parties involved.\n2. Obligations of the Recipient to maintain confidentiality.\n3. Duration of the confidentiality obligation.\n4. Permitted disclosures and exceptions.\n5. Consequences for breach of the NDA.\n6. Dispute resolution mechanisms (not implemented in this example).\n7. Constructor function to initialize the contract with the relevant parties and terms.\n\nPlease note that this contract is not legally binding and should be reviewed by a legal expert. Additionally, it is not secure against potential attacks and should be audited by a blockchain security expert before deploying it on the mainnet.",
    "Rental Agreement": "Here's a Solidity smart contract for a Rental Agreement with the mentioned features:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract RentalAgreement {\n    // Definitions of the Lessor and Lessee\n    address public lessor;\n    address public lessee;\n\n    // Description of the leased property and rental terms\n    string public propertyDescription;\n    uint256 public rentalDuration; // in days\n    uint256 public dailyRent;\n\n    // Payment schedule for rent\n    event RentPaid(address indexed payer, uint256 amount);\n    uint256 public accumulatedRent;\n    uint256 public lateFeePerDay;\n    uint256 public gracePeriod; // in days\n\n    // Security deposit handling\n    uint256 public securityDeposit;\n    bool public depositReturned;\n\n    // Maintenance and repair obligations\n    enum MaintenanceStatus {\n        Pending,\n        Assigned,\n        Completed\n    }\n    struct MaintenanceRequest {\n        address requester;\n        string description;\n        MaintenanceStatus status;\n        uint256 deadline; // in days\n    }\n    MaintenanceRequest[] public maintenanceRequests;\n\n    // Termination and renewal clauses\n    uint256 public noticePeriod; // in days\n    bool public isTerminated;\n\n    // Dispute resolution mechanisms\n    address public arbitrator;\n\n    constructor(\n        address _lessor,\n        address _lessee,\n        string memory _propertyDescription,\n        uint256 _rentalDuration,\n        uint256 _dailyRent,\n        uint256 _accumulatedRent,\n        uint256 _lateFeePerDay,\n        uint256 _gracePeriod,\n        uint256 _securityDeposit,\n        uint256 _noticePeriod,\n        address _arbitrator\n    ) {\n        lessor = _lessor;\n        lessee = _lessee;\n        propertyDescription = _propertyDescription;\n        rentalDuration = _rentalDuration;\n        dailyRent = _dailyRent;\n        accumulatedRent = _accumulatedRent;\n        lateFeePerDay = _lateFeePerDay;\n        gracePeriod = _gracePeriod;\n        securityDeposit = _securityDeposit;\n        noticePeriod = _noticePeriod;\n        arbitrator = _arbitrator;\n    }\n\n    // Other functions for handling payments, maintenance, termination, etc.\n}\n```\n\nThis smart contract provides a basic structure for a Rental Agreement. However, it is not complete and requires additional functions to handle the various features mentioned. For instance, you would need to add functions for handling rent payments, creating and updating maintenance requests, terminating the agreement, and resolving disputes.\n\nPlease note that this smart contract is for educational purposes only and should not be used as-is in a production environment. It may contain errors or omissions and should be thoroughly tested and audited before deployment."
}